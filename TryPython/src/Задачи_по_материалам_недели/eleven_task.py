"""

Напишите программу, на вход которой подаётся прямоугольная матрица в виде последовательности строк, заканчивающихся
строкой, содержащей только строку "end" (без кавычек)

Программа должна вывести матрицу того же размера, у которой каждый элемент в позиции i, j равен сумме элементов
первой матрицы на позициях (i-1, j), (i+1, j), (i, j-1), (i, j+1). У крайних символов соседний элемент находится с
противоположной стороны матрицы.

В случае одной строки/столбца элемент сам себе является соседом по соответствующему направлению.

Sample Input 1:

9 5 3
0 7 -1
-5 2 9
end
Sample Output 1:

3 21 22
10 6 19
20 16 -1
Sample Input 2:

1
end
Sample Output 2:

4

"""

n = ''  # создали пустую строку
m = []  # создали пустой список
while True:
    n = str(input())  # ввод строк
    # если встречаем слово end , то прерываем цикл
    if n == 'end':
        break

        # очевидно, количество столбцов в двумерном списке. с - двумерный список. len(c) - количество элементов этого
        #  списка, т.е. строк. c[0] - нулевой элемент этого списка (строка). Поэтому len(c[0]) возвращает количество
        # элементов в нулевой строке двумерного списка, т.е. количество столбцов в двумерном списке. c.append(),
        # вообще говоря, НЕ превращает одномерный список в двумерный. Но двумерный список это просто одномерный
        # список, элементами которого являются другие списки. Именно это в решении и происходит. В пустой (
        # одномерный) список добавляются другие списки, получается список списков, т.е. двумерный список.
    m.append([int(s) for s in n.split()])  # заполняем   список значениями нашей введенной матрицы(списками,
    # содержащие элементы на строке)
li, lj = len(m), len(m[0])  # узнаем значения длины  всего списка и первого элемента(длина строки и столбца)

# у которой каждый элемент в позиции i, j равен сумме элементов
# первой матрицы на позициях (i-1, j), (i+1, j), (i, j-1), (i, j+1). У крайних символов соседний элемент находится с
# противоположной стороны матрицы.
new = [[sum([m[i - 1][j], m[(i + 1) % li][j], m[i][j - 1], m[i][(j + 1) % lj]]) for j in range(lj)] for i in range(li)]

# выводим полученную матрицу на экран
for i in range(li):
    for j in range(lj):
        print(new[i][j], end=' ')
    print()
